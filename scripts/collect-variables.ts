// Code generated with Gemini

import * as fs from 'fs';
import * as path from 'path';

interface VariableDefinition {
  name: string;
  description: string;
  submodules: string[];
  customInfo?: Record<string, any>;
}

interface SubmoduleVariables {
  [submodulePath: string]: VariableDefinition[];
}

const ROOT_DIR = '.';
const OUTPUT_FILE = 'variables.tf';
const VARIABLE_FILE_NAME = 'cdk.tf.json';
const GENERATED_COMMENT_START = '# Variables generated by terraform-variable-collector start';
const GENERATED_COMMENT_END = '# Variables generated by terraform-variable-collector end';

/**
 * Extracts variable definitions from a cdk.tf.json file.
 */
function extractVariables(filePath: string): VariableDefinition[] {
  try {
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const jsonData = JSON.parse(fileContent);

    if (!jsonData.variable || typeof jsonData.variable !== 'object') {
      return [];
    }

    const variables: VariableDefinition[] = [];
    for (const varName in jsonData.variable) {
      if (jsonData.variable.hasOwnProperty(varName)) {
        const varConfig = jsonData.variable[varName];
        if (typeof varConfig === 'object' && varConfig !== null) {
          const description = typeof varConfig.description === 'string' ? varConfig.description : 'No description provided.';
          const customInfo = varConfig.customInfo ? varConfig.customInfo : {};
          variables.push({ name: varName, description, submodules: [], customInfo });
        }
      }
    }
    return variables;
  } catch (error) {
    console.error(`Error processing file: ${filePath}`, error);
    return [];
  }
}

/**
 * Recursively searches for cdk.tf.json files within the "modules" subdirectory.
 */
function findSubmoduleVariables(dir: string): SubmoduleVariables {
  const submoduleVariables: SubmoduleVariables = {};
  const modulesDir = path.join(dir, 'modules');

  if (!fs.existsSync(modulesDir)) {
    console.warn(`Warning: 'modules' directory not found at ${modulesDir}.  No variables will be collected.`);
    return {};
  }

  function walk(currentDir: string) {
    const files = fs.readdirSync(currentDir);
    for (const file of files) {
      const filePath = path.join(currentDir, file);
      const stat = fs.statSync(filePath);

      if (stat.isDirectory()) {
        walk(filePath);
      } else if (file === VARIABLE_FILE_NAME) {
        const submodulePath = path.relative(modulesDir, currentDir);
        if (submodulePath) {
          const variables = extractVariables(filePath);
          if (variables.length > 0) {
            submoduleVariables[submodulePath] = variables;
          }
        }
      }
    }
  }

  walk(modulesDir);
  return submoduleVariables;
}

/**
 * Generates the content for the root module's variables.tf file, combining
 * similarly named variables. It uses the description from the first
 * occurrence of the variable.  It now updates an existing file, preserving
 * content outside of the generated variable block.
 */
function generateRootVariablesTf(collectedVariables: SubmoduleVariables): void {
  let existingContent = '';
  if (fs.existsSync(OUTPUT_FILE)) {
    existingContent = fs.readFileSync(OUTPUT_FILE, 'utf-8');
  }

  let outputContent = `${GENERATED_COMMENT_START}\n`;
  const combinedVariables: { [name: string]: VariableDefinition } = {};

  for (const submodulePath in collectedVariables) {
    if (collectedVariables.hasOwnProperty(submodulePath)) {
      const variables = collectedVariables[submodulePath];
      for (const variable of variables) {
        if (combinedVariables[variable.name]) {
          // Variable name already exists, so combine, but keep original description
          combinedVariables[variable.name].submodules.push(`modules/${submodulePath}`);
        } else {
          // Variable name doesn't exist, so add it
          combinedVariables[variable.name] = {
            ...variable,
            submodules: [`modules/${submodulePath}`],
          };
        }
      }
    }
  }

  for (const varName in combinedVariables) {
    if (combinedVariables.hasOwnProperty(varName)) {
      const variable = combinedVariables[varName];
      const submoduleList = variable.submodules.join(', ');
      outputContent += `variable "${varName}" {\n`;
      outputContent += `  type = any\n`;
      outputContent += `  description = "${variable.description} (Defined in: ${submoduleList})"\n`;
      if (variable.customInfo && Object.keys(variable.customInfo).length > 0) {
        outputContent += `  # Custom Information:\n`;
        for (const key in variable.customInfo) {
          if (variable.customInfo.hasOwnProperty(key)) {
            const value = variable.customInfo[key];
            outputContent += `  #   ${key} = ${JSON.stringify(value)}\n`;
          }
        }
      }
      outputContent += `}\n\n`;
    }
  }
  outputContent += `${GENERATED_COMMENT_END}\n`;

  // Use regular expressions to find and replace the generated block
  const startMarkerRegex = new RegExp(GENERATED_COMMENT_START.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
  const endMarkerRegex = new RegExp(GENERATED_COMMENT_END.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
  const existingGeneratedBlockRegex = new RegExp(
    `${startMarkerRegex.source}[\\s\\S]*${endMarkerRegex.source}`,
    'g',
  );

  let updatedContent: string;
  if (existingGeneratedBlockRegex.test(existingContent)) {
    // Replace the existing generated block with the new content
    updatedContent = existingContent.replace(existingGeneratedBlockRegex, outputContent);
  } else {
    // Append the generated block to the end of the file, or create a new file
    updatedContent = existingContent + outputContent;
  }

  fs.writeFileSync(OUTPUT_FILE, updatedContent);
  console.log(
    `Generated (or updated) root module's ${OUTPUT_FILE} with combined variables, preserving existing content.`,
  );
  console.log('Review and adjust the types and other attributes as needed.');
}

function main(): void {
  const collectedVars = findSubmoduleVariables(ROOT_DIR);

  if (Object.keys(collectedVars).length > 0) {
    console.log('Collected variables from submodules:');
    for (const submodulePath in collectedVars) {
      if (collectedVars.hasOwnProperty(submodulePath)) {
        console.log(`  Submodule: modules/${submodulePath}`);
        const variables = collectedVars[submodulePath];
        for (const varDef of variables) {
          console.log(`    - Name: ${varDef.name}, Description: ${varDef.description}`);
        }
      }
    }
    generateRootVariablesTf(collectedVars);
  } else {
    console.log('No submodules with cdk.tf.json files found in the "modules" directory.');
  }
}

main();

